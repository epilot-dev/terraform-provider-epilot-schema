// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	tfTypes "github.com/epilot/terraform-provider-epilot-schema/internal/provider/types"
	"github.com/epilot/terraform-provider-epilot-schema/internal/sdk"
	"github.com/epilot/terraform-provider-epilot-schema/internal/sdk/models/operations"
	"github.com/epilot/terraform-provider-epilot-schema/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &SchemaAttributeResource{}
var _ resource.ResourceWithImportState = &SchemaAttributeResource{}

func NewSchemaAttributeResource() resource.Resource {
	return &SchemaAttributeResource{}
}

// SchemaAttributeResource defines the resource implementation.
type SchemaAttributeResource struct {
	client *sdk.SDK
}

// SchemaAttributeResourceModel describes the resource data model.
type SchemaAttributeResourceModel struct {
	AddressRelationAttribute       *tfTypes.AddressRelationAttribute       `tfsdk:"address_relation_attribute" tfPlanOnly:"true"`
	Attribute                      *tfTypes.Attribute                      `tfsdk:"attribute"`
	AutomationAttribute            *tfTypes.AutomationAttribute            `tfsdk:"automation_attribute" tfPlanOnly:"true"`
	BooleanAttribute               *tfTypes.BooleanAttribute               `tfsdk:"boolean_attribute" tfPlanOnly:"true"`
	CompositeID                    types.String                            `tfsdk:"composite_id"`
	ComputedAttribute              *tfTypes.ComputedAttribute              `tfsdk:"computed_attribute" tfPlanOnly:"true"`
	ConsentAttribute               *tfTypes.ConsentAttribute               `tfsdk:"consent_attribute" tfPlanOnly:"true"`
	CountryAttribute               *tfTypes.CountryAttribute               `tfsdk:"country_attribute" tfPlanOnly:"true"`
	CurrencyAttribute              *tfTypes.CurrencyAttribute              `tfsdk:"currency_attribute" tfPlanOnly:"true"`
	DateAttribute                  *tfTypes.DateAttribute                  `tfsdk:"date_attribute" tfPlanOnly:"true"`
	FileAttribute                  *tfTypes.FileAttribute                  `tfsdk:"file_attribute" tfPlanOnly:"true"`
	InternalAttribute              *tfTypes.InternalAttribute              `tfsdk:"internal_attribute" tfPlanOnly:"true"`
	InternalUserAttribute          *tfTypes.InternalUserAttribute          `tfsdk:"internal_user_attribute" tfPlanOnly:"true"`
	InvitationEmailAttribute       *tfTypes.InvitationEmailAttribute       `tfsdk:"invitation_email_attribute" tfPlanOnly:"true"`
	LinkAttribute                  *tfTypes.LinkAttribute                  `tfsdk:"link_attribute" tfPlanOnly:"true"`
	MultiSelectAttribute           *tfTypes.MultiSelectAttribute           `tfsdk:"multi_select_attribute" tfPlanOnly:"true"`
	NumberAttribute                *tfTypes.NumberAttribute                `tfsdk:"number_attribute" tfPlanOnly:"true"`
	OrderedListAttribute           *tfTypes.OrderedListAttribute           `tfsdk:"ordered_list_attribute" tfPlanOnly:"true"`
	PartnerOrganisationAttribute   *tfTypes.PartnerOrganisationAttribute   `tfsdk:"partner_organisation_attribute" tfPlanOnly:"true"`
	PartnerStatusAttribute         *tfTypes.PartnerStatusAttribute         `tfsdk:"partner_status_attribute" tfPlanOnly:"true"`
	PaymentMethodRelationAttribute *tfTypes.PaymentMethodRelationAttribute `tfsdk:"payment_method_relation_attribute" tfPlanOnly:"true"`
	PurposeAttribute               *tfTypes.PurposeAttribute               `tfsdk:"purpose_attribute" tfPlanOnly:"true"`
	RelationAttribute              *tfTypes.RelationAttribute              `tfsdk:"relation_attribute" tfPlanOnly:"true"`
	RepeatableAttribute            *tfTypes.RepeatableAttribute            `tfsdk:"repeatable_attribute" tfPlanOnly:"true"`
	SelectAttribute                *tfTypes.SelectAttribute                `tfsdk:"select_attribute" tfPlanOnly:"true"`
	SequenceAttribute              *tfTypes.SequenceAttribute              `tfsdk:"sequence_attribute" tfPlanOnly:"true"`
	Slug                           types.String                            `tfsdk:"slug"`
	StatusAttribute                *tfTypes.StatusAttribute                `tfsdk:"status_attribute" tfPlanOnly:"true"`
	TagsAttribute                  *tfTypes.TagsAttribute                  `tfsdk:"tags_attribute" tfPlanOnly:"true"`
	TextAttribute                  *tfTypes.TextAttribute                  `tfsdk:"text_attribute" tfPlanOnly:"true"`
	UserRelationAttribute          *tfTypes.UserRelationAttribute          `tfsdk:"user_relation_attribute" tfPlanOnly:"true"`
}

func (r *SchemaAttributeResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_schema_attribute"
}

func (r *SchemaAttributeResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "SchemaAttribute Resource",
		Attributes: map[string]schema.Attribute{
			"address_relation_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"has_primary": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["relation_address"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"relation_address",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Reference to an address attribute of another entity. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"attribute": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"address_relation_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"has_primary": schema.BoolAttribute{
								Computed: true,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["relation_address"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"relation_address",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Reference to an address attribute of another entity`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"automation_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["automation"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"automation",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Automation entity`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"boolean_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["boolean"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"boolean",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Yes / No Toggle`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"computed_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["computed"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"computed",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `An attribute that is computed from the entity data. For more details on how to use them, check the docs [here](https://e-pilot.atlassian.net/wiki/spaces/EO/pages/5642977476/How+To+Computed+Schema+Attributes)`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"consent_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"identifiers": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"topic": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["consent"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"consent",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Consent Management`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"country_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["country"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"country",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Country picker`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"currency_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"currency": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"one": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"code": schema.StringAttribute{
													Computed: true,
												},
												"description": schema.StringAttribute{
													Computed: true,
												},
												"flag": schema.StringAttribute{
													Computed: true,
												},
												"symbol": schema.StringAttribute{
													Computed: true,
												},
											},
											Description: `A currency configuration`,
										},
									},
									Validators: []validator.Object{
										validators.ExactlyOneChild(),
									},
								},
								Description: `An array of currency configurations with a country code (ISO-4217)`,
							},
							"currency_selector_only": schema.BoolAttribute{
								Computed: true,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["currency"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"currency",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Currency input`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"date_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["date", "datetime"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"date",
										"datetime",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Date or Datetime picker`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"file_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"allowed_extensions": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `List of file extensions (without the dot suffix)`,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_access_control": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["public-read", "private"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"public-read",
										"private",
									),
								},
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"display_images_landscaped": schema.BoolAttribute{
								Computed:    true,
								Description: `Controls how the images are presented to the user during upload on the Entity Details view.`,
							},
							"enable_description": schema.BoolAttribute{
								Computed: true,
								MarkdownDescription: `When set to true, an i18n description will be used alongside the attribute label.` + "\n" +
									`This description should be set through the platform locales in the form: ` + "`" + `file.{attribute_name}.description_text` + "`" + `.` + "\n" +
									``,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"multiple": schema.BoolAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["image", "file"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"image",
										"file",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `File or Image Attachment`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"internal_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["internal"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"internal",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `No UI representation`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"internal_user_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["internal_user"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"internal_user",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Epilot internal user info`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"invitation_email_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["invitation_email"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"invitation_email",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Email address for send invitation`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"link_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["link"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"link",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Link with title and href`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"multi_select_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"allow_any": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow arbitrary input values in addition to provided options`,
							},
							"allow_extra_options": schema.BoolAttribute{
								Computed:    true,
								Description: `controls if the 360 ui will allow the user to enter a value which is not defined by the options`,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"disable_case_sensitive": schema.BoolAttribute{
								Computed:    true,
								Description: `controls if the matching of values against the options is case sensitive or not`,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"options": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"str": schema.StringAttribute{
											Computed: true,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("two"),
												}...),
											},
										},
										"two": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"title": schema.StringAttribute{
													Computed: true,
												},
												"value": schema.StringAttribute{
													Computed: true,
												},
											},
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("str"),
												}...),
											},
										},
									},
									Validators: []validator.Object{
										validators.ExactlyOneChild(),
									},
								},
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["multiselect", "checkbox"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"multiselect",
										"checkbox",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Multi Choice Selection`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"number_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"format": schema.StringAttribute{
								Computed: true,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["number"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"number",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Numeric input`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"ordered_list_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["ordered_list"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ordered_list",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Type of attribute to render N number of ordered fields`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"partner_organisation_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["partner_organisation"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"partner_organisation",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Shared Partner Organisations`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"partner_status_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["partner_status"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"partner_status",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Partner Status`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"payment_method_relation_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"has_primary": schema.BoolAttribute{
								Computed: true,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["relation_payment_method"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"relation_payment_method",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Reference to a payment method attribute of another entity`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"purpose_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"created_at": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed: true,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"parents": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"slug": schema.StringAttribute{
								Computed:    true,
								Description: `URL-friendly identifier for the classification`,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["purpose"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"purpose",
									),
								},
							},
							"updated_at": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Entity Taxonomy`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"relation_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"actions": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"action_type": schema.StringAttribute{
											Computed: true,
											MarkdownDescription: `The action type. Currently supported actions:` + "\n" +
												`` + "\n" +
												`| action | description |` + "\n" +
												`|--------|-------------|` + "\n" +
												`| add_existing | Enables the user to pick an existing entity to link as relation |` + "\n" +
												`| create_new | Enables the user to create a new entity using the first/main ` + "`" + `allowed_schemas` + "`" + ` schema` + "\n" +
												`| create_from_existing | Enables the user to pick an existing entity to clone from, while creating a blank new entity to link as relation |` + "\n" +
												`` + "\n" +
												`must be one of ["add_existing", "create_new", "create_from_existing"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"add_existing",
													"create_new",
													"create_from_existing",
												),
											},
										},
										"default": schema.BoolAttribute{
											Computed:    true,
											Description: `Sets the action as the default action, visible as the main action button.`,
										},
										"feature_flag": schema.StringAttribute{
											Computed:    true,
											Description: `Name of the feature flag that enables this action`,
										},
										"label": schema.StringAttribute{
											Computed:    true,
											Description: `The action label or action translation key (i18n)`,
										},
										"new_entity_item": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"acl": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"additional_properties": schema.StringAttribute{
															Computed:    true,
															Description: `Parsed as JSON.`,
															Validators: []validator.String{
																validators.IsValidJSON(),
															},
														},
														"delete": schema.ListAttribute{
															Computed:    true,
															ElementType: types.StringType,
														},
														"edit": schema.ListAttribute{
															Computed:    true,
															ElementType: types.StringType,
														},
														"view": schema.ListAttribute{
															Computed:    true,
															ElementType: types.StringType,
														},
													},
													Description: `Access control list (ACL) for an entity. Defines sharing access to external orgs or users.`,
												},
												"created_at": schema.StringAttribute{
													Computed: true,
													Validators: []validator.String{
														validators.IsRFC3339(),
													},
												},
												"id": schema.StringAttribute{
													Computed: true,
												},
												"org": schema.StringAttribute{
													Computed:    true,
													Description: `Organization Id the entity belongs to`,
												},
												"owners": schema.ListNestedAttribute{
													Computed: true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"org_id": schema.StringAttribute{
																Computed: true,
															},
															"user_id": schema.StringAttribute{
																Computed: true,
															},
														},
													},
												},
												"schema": schema.StringAttribute{
													Computed:    true,
													Description: `URL-friendly identifier for the entity schema`,
												},
												"tags": schema.ListAttribute{
													Computed:    true,
													ElementType: types.StringType,
												},
												"title": schema.StringAttribute{
													Computed:    true,
													Description: `Title of entity`,
												},
												"updated_at": schema.StringAttribute{
													Computed: true,
													Validators: []validator.String{
														validators.IsRFC3339(),
													},
												},
												"additional_properties": schema.StringAttribute{
													Computed:    true,
													Description: `Parsed as JSON.`,
													Validators: []validator.String{
														validators.IsValidJSON(),
													},
												},
											},
										},
										"settings_flag": schema.ListNestedAttribute{
											Computed: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"enabled": schema.BoolAttribute{
														Computed:    true,
														Description: `Whether the setting should be enabled or not`,
													},
													"name": schema.StringAttribute{
														Computed:    true,
														Description: `The name of the organization setting to check`,
													},
												},
											},
											Description: `This action should only be active when all the settings have the correct value`,
										},
									},
								},
							},
							"add_button_label": schema.StringAttribute{
								Computed:    true,
								Description: `Optional label for the add button. The translated value for add_button_lable is used, if found else the string is used as is.`,
							},
							"allowed_schemas": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"details_view_mode_enabled": schema.BoolAttribute{
								Computed:    true,
								Description: `Enables the preview, edition, and creation of relation items on a Master-Details view mode.`,
							},
							"drawer_size": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["small", "medium", "large"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"small",
										"medium",
										"large",
									),
								},
							},
							"edit_mode": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["list-view"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"list-view",
									),
								},
							},
							"enable_relation_picker": schema.BoolAttribute{
								Computed:    true,
								Description: `When enable_relation_picker is set to true the user will be able to pick existing relations as values. Otherwise, the user will need to create new relation to link.`,
							},
							"enable_relation_tags": schema.BoolAttribute{
								Computed:    true,
								Description: `When enable_relation_tags is set to true the user will be able to set tags(labels) in each relation item.`,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"has_primary": schema.BoolAttribute{
								Computed: true,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"relation_affinity_mode": schema.StringAttribute{
								Computed:    true,
								Description: `Weak relation attributes are kept when duplicating an entity. Strong relation attributes are discarded when duplicating an entity. must be one of ["weak", "strong"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"weak",
										"strong",
									),
								},
							},
							"relation_type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["has_many", "has_one"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"has_many",
										"has_one",
									),
								},
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"reverse_attributes": schema.MapAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `Map of schema slug to target relation attribute`,
							},
							"search_placeholder": schema.StringAttribute{
								Computed:    true,
								Description: `Optional placeholder text for the relation search input. The translated value for search_placeholder is used, if found else the string is used as is.`,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"summary_fields": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"str": schema.StringAttribute{
											Computed: true,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("summary_field"),
												}...),
											},
										},
										"summary_field": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"display_as": schema.StringAttribute{
													Computed:    true,
													Description: `An hint on how to display the summary field`,
												},
												"field": schema.StringAttribute{
													Computed:    true,
													Description: `The field from the entity attributes to display`,
												},
											},
											Description: `Summary Fields are displayed inside list view as a resume of the relation entity.`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("str"),
												}...),
											},
										},
									},
									Validators: []validator.Object{
										validators.ExactlyOneChild(),
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["relation"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"relation",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Entity Relationship`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"repeatable_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"enable_relation_picker": schema.BoolAttribute{
								Computed:    true,
								Description: `when enable_relation_picker is set to true the user will be able to pick existing relations as values. Otherwise, the user will need to create new relation to link.`,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"has_primary": schema.BoolAttribute{
								Computed: true,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"relation_affinity_mode": schema.StringAttribute{
								Computed:    true,
								Description: `Weak repeatable attributes are kept when duplicating an entity. Strong repeatable attributes are discarded when duplicating an entity. must be one of ["weak", "strong"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"weak",
										"strong",
									),
								},
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"repeatable": schema.BoolAttribute{
								Computed: true,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["string", "phone", "email", "address", "relation", "payment", "price_component", "date"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"string",
										"phone",
										"email",
										"address",
										"relation",
										"payment",
										"price_component",
										"date",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Repeatable (add N number of fields)`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"select_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"allow_any": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow arbitrary input values in addition to provided options`,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"options": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"str": schema.StringAttribute{
											Computed: true,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("one"),
												}...),
											},
										},
										"one": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"title": schema.StringAttribute{
													Computed: true,
												},
												"value": schema.StringAttribute{
													Computed: true,
												},
											},
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("str"),
												}...),
											},
										},
									},
									Validators: []validator.Object{
										validators.ExactlyOneChild(),
									},
								},
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["select", "radio"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"select",
										"radio",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Dropdown select`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"sequence_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"prefix": schema.StringAttribute{
								Computed:    true,
								Description: `Prefix added before the sequence number`,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"start_number": schema.Int64Attribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["sequence"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"sequence",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Sequence of unique identifiers`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"status_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"options": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"str": schema.StringAttribute{
											Computed: true,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("two"),
												}...),
											},
										},
										"two": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"title": schema.StringAttribute{
													Computed:    true,
													Description: `The displayed title of the option`,
												},
												"value": schema.StringAttribute{
													Computed:    true,
													Description: `The stored value of the option`,
												},
											},
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("str"),
												}...),
											},
										},
									},
									Validators: []validator.Object{
										validators.ExactlyOneChild(),
									},
								},
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["status"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"status",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Status select`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"tags_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"options": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"suggestions": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["tags"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"tags",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Tags`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"text_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"multiline": schema.BoolAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["string"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"string",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `Textarea or text input`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("user_relation_attribute"),
							}...),
						},
					},
					"user_relation_attribute": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"purpose": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
							},
							"constraints": schema.SingleNestedAttribute{
								Computed:   true,
								Attributes: map[string]schema.Attribute{},
								MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
									`These constraints should and will be enforced by the attribute renderer.` + "\n" +
									``,
							},
							"default_value": schema.StringAttribute{
								Computed:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"deprecated": schema.BoolAttribute{
								Computed: true,
							},
							"entity_builder_disable_edit": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI`,
							},
							"feature_flag": schema.StringAttribute{
								Computed:    true,
								Description: `This attribute should only be active when the feature flag is enabled`,
							},
							"group": schema.StringAttribute{
								Computed:    true,
								Description: `Which group the attribute should appear in. Accepts group ID or group name`,
							},
							"hidden": schema.BoolAttribute{
								Computed:    true,
								Description: `Do not render attribute in entity views`,
							},
							"hide_label": schema.BoolAttribute{
								Computed:    true,
								Description: `When set to true, will hide the label of the field.`,
							},
							"icon": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
									`The value must be a valid @epilot/base-elements Icon name` + "\n" +
									``,
							},
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `ID for the entity attribute`,
							},
							"info_helpers": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"hint_custom_component": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
											`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
											`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
											``,
									},
									"hint_text_key": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
											`The key should be a valid i18n key.` + "\n" +
											``,
									},
									"hint_tooltip_placement": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
											`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
											``,
									},
								},
								Description: `A set of configurations meant to document and assist the user in filling the attribute.`,
							},
							"label": schema.StringAttribute{
								Computed: true,
							},
							"layout": schema.StringAttribute{
								Computed: true,
							},
							"multiple": schema.BoolAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"order": schema.Int64Attribute{
								Computed:    true,
								Description: `Attribute sort order (ascending) in group`,
							},
							"placeholder": schema.StringAttribute{
								Computed: true,
							},
							"preview_value_formatter": schema.StringAttribute{
								Computed: true,
							},
							"protected": schema.BoolAttribute{
								Computed:    true,
								Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted`,
							},
							"readonly": schema.BoolAttribute{
								Computed: true,
							},
							"render_condition": schema.StringAttribute{
								Computed: true,
								MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
									`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
									`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
									``,
							},
							"required": schema.BoolAttribute{
								Computed: true,
							},
							"settings_flag": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"enabled": schema.BoolAttribute{
											Computed:    true,
											Description: `Whether the setting should be enabled or not`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of the organization setting to check`,
										},
									},
								},
								Description: `This attribute should only be active when all the settings have the correct value`,
							},
							"show_in_table": schema.BoolAttribute{
								Computed:    true,
								Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + ``,
							},
							"sortable": schema.BoolAttribute{
								Computed:    true,
								Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["relation_user"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"relation_user",
									),
								},
							},
							"value_formatter": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `User Relationship`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("address_relation_attribute"),
								path.MatchRelative().AtParent().AtName("automation_attribute"),
								path.MatchRelative().AtParent().AtName("boolean_attribute"),
								path.MatchRelative().AtParent().AtName("computed_attribute"),
								path.MatchRelative().AtParent().AtName("consent_attribute"),
								path.MatchRelative().AtParent().AtName("country_attribute"),
								path.MatchRelative().AtParent().AtName("currency_attribute"),
								path.MatchRelative().AtParent().AtName("date_attribute"),
								path.MatchRelative().AtParent().AtName("file_attribute"),
								path.MatchRelative().AtParent().AtName("internal_attribute"),
								path.MatchRelative().AtParent().AtName("internal_user_attribute"),
								path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
								path.MatchRelative().AtParent().AtName("link_attribute"),
								path.MatchRelative().AtParent().AtName("multi_select_attribute"),
								path.MatchRelative().AtParent().AtName("number_attribute"),
								path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
								path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
								path.MatchRelative().AtParent().AtName("partner_status_attribute"),
								path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
								path.MatchRelative().AtParent().AtName("purpose_attribute"),
								path.MatchRelative().AtParent().AtName("relation_attribute"),
								path.MatchRelative().AtParent().AtName("repeatable_attribute"),
								path.MatchRelative().AtParent().AtName("select_attribute"),
								path.MatchRelative().AtParent().AtName("sequence_attribute"),
								path.MatchRelative().AtParent().AtName("status_attribute"),
								path.MatchRelative().AtParent().AtName("tags_attribute"),
								path.MatchRelative().AtParent().AtName("text_attribute"),
							}...),
						},
					},
				},
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"automation_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["automation"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"automation",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Automation entity. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"boolean_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["boolean"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"boolean",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Yes / No Toggle. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"composite_id": schema.StringAttribute{
				Computed:    true,
				Description: `Schema Slug and the Attribute ID`,
			},
			"computed_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["computed"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"computed",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `An attribute that is computed from the entity data. For more details on how to use them, check the docs [here](https://e-pilot.atlassian.net/wiki/spaces/EO/pages/5642977476/How+To+Computed+Schema+Attributes). Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"consent_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"identifiers": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"topic": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. ; must be one of ["consent"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"consent",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Consent Management. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"country_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["country"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"country",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Country picker. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"currency_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"currency": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"one": schema.SingleNestedAttribute{
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"code": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Requires replacement if changed. `,
										},
										"description": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Requires replacement if changed. `,
										},
										"flag": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional:    true,
											Description: `Requires replacement if changed. `,
										},
										"symbol": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Requires replacement if changed. `,
										},
									},
									Description: `A currency configuration. Requires replacement if changed. `,
								},
							},
							Validators: []validator.Object{
								validators.ExactlyOneChild(),
							},
						},
						Description: `An array of currency configurations with a country code (ISO-4217). Requires replacement if changed. `,
					},
					"currency_selector_only": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. ; must be one of ["currency"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"currency",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Currency input. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"date_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["date", "datetime"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"date",
								"datetime",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Date or Datetime picker. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"file_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"allowed_extensions": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `List of file extensions (without the dot suffix). Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_access_control": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["public-read", "private"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"public-read",
								"private",
							),
						},
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"display_images_landscaped": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Controls how the images are presented to the user during upload on the Entity Details view. Requires replacement if changed. `,
					},
					"enable_description": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `When set to true, an i18n description will be used alongside the attribute label.` + "\n" +
							`This description should be set through the platform locales in the form: ` + "`" + `file.{attribute_name}.description_text` + "`" + `.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"multiple": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. ; must be one of ["image", "file"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"image",
								"file",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `File or Image Attachment. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"internal_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["internal"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"internal",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `No UI representation. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"internal_user_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["internal_user"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"internal_user",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Epilot internal user info. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"invitation_email_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["invitation_email"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"invitation_email",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Email address for send invitation. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"link_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["link"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"link",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Link with title and href. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"multi_select_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"allow_any": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Allow arbitrary input values in addition to provided options. Requires replacement if changed. `,
					},
					"allow_extra_options": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `controls if the 360 ui will allow the user to enter a value which is not defined by the options. Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"disable_case_sensitive": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `controls if the matching of values against the options is case sensitive or not. Requires replacement if changed. `,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"options": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"str": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Requires replacement if changed. `,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("two"),
										}...),
									},
								},
								"two": schema.SingleNestedAttribute{
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"title": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional:    true,
											Description: `Requires replacement if changed. `,
										},
										"value": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Requires replacement if changed. `,
										},
									},
									Description: `Requires replacement if changed. `,
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("str"),
										}...),
									},
								},
							},
							Validators: []validator.Object{
								validators.ExactlyOneChild(),
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["multiselect", "checkbox"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"multiselect",
								"checkbox",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Multi Choice Selection. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"number_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"format": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["number"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"number",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Numeric input. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"ordered_list_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["ordered_list"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ordered_list",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Type of attribute to render N number of ordered fields. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"partner_organisation_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["partner_organisation"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"partner_organisation",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Shared Partner Organisations. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"partner_status_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["partner_status"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"partner_status",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Partner Status. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"payment_method_relation_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"has_primary": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["relation_payment_method"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"relation_payment_method",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Reference to a payment method attribute of another entity. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"purpose_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"created_at": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
						Validators: []validator.String{
							validators.IsRFC3339(),
						},
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"parents": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"slug": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `URL-friendly identifier for the classification. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["purpose"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"purpose",
							),
						},
					},
					"updated_at": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
						Validators: []validator.String{
							validators.IsRFC3339(),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Entity Taxonomy. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"relation_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"actions": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"action_type": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional: true,
									MarkdownDescription: `The action type. Currently supported actions:` + "\n" +
										`` + "\n" +
										`| action | description |` + "\n" +
										`|--------|-------------|` + "\n" +
										`| add_existing | Enables the user to pick an existing entity to link as relation |` + "\n" +
										`| create_new | Enables the user to create a new entity using the first/main ` + "`" + `allowed_schemas` + "`" + ` schema` + "\n" +
										`| create_from_existing | Enables the user to pick an existing entity to clone from, while creating a blank new entity to link as relation |` + "\n" +
										`` + "\n" +
										`Requires replacement if changed. ; must be one of ["add_existing", "create_new", "create_from_existing"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"add_existing",
											"create_new",
											"create_from_existing",
										),
									},
								},
								"default": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Sets the action as the default action, visible as the main action button. Requires replacement if changed. `,
								},
								"feature_flag": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Name of the feature flag that enables this action. Requires replacement if changed. `,
								},
								"label": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The action label or action translation key (i18n). Requires replacement if changed. `,
								},
								"new_entity_item": schema.SingleNestedAttribute{
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"acl": schema.SingleNestedAttribute{
											PlanModifiers: []planmodifier.Object{
												objectplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"additional_properties": schema.StringAttribute{
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.RequiresReplaceIfConfigured(),
													},
													Optional:    true,
													Description: `Parsed as JSON.`,
													Validators: []validator.String{
														validators.IsValidJSON(),
													},
												},
												"delete": schema.ListAttribute{
													PlanModifiers: []planmodifier.List{
														listplanmodifier.RequiresReplaceIfConfigured(),
													},
													Optional:    true,
													ElementType: types.StringType,
													Description: `Requires replacement if changed. `,
												},
												"edit": schema.ListAttribute{
													PlanModifiers: []planmodifier.List{
														listplanmodifier.RequiresReplaceIfConfigured(),
													},
													Optional:    true,
													ElementType: types.StringType,
													Description: `Requires replacement if changed. `,
												},
												"view": schema.ListAttribute{
													PlanModifiers: []planmodifier.List{
														listplanmodifier.RequiresReplaceIfConfigured(),
													},
													Optional:    true,
													ElementType: types.StringType,
													Description: `Requires replacement if changed. `,
												},
											},
											Description: `Access control list (ACL) for an entity. Defines sharing access to external orgs or users. Requires replacement if changed. `,
										},
										"created_at": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Requires replacement if changed. `,
											Validators: []validator.String{
												validators.IsRFC3339(),
											},
										},
										"id": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Requires replacement if changed. `,
										},
										"org": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Organization Id the entity belongs to. Requires replacement if changed. `,
										},
										"owners": schema.ListNestedAttribute{
											PlanModifiers: []planmodifier.List{
												listplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"org_id": schema.StringAttribute{
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.RequiresReplaceIfConfigured(),
														},
														Required:    true,
														Description: `Requires replacement if changed. `,
													},
													"user_id": schema.StringAttribute{
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.RequiresReplaceIfConfigured(),
														},
														Optional:    true,
														Description: `Requires replacement if changed. `,
													},
												},
											},
											Description: `Requires replacement if changed. `,
										},
										"schema": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `URL-friendly identifier for the entity schema. Requires replacement if changed. `,
										},
										"tags": schema.ListAttribute{
											PlanModifiers: []planmodifier.List{
												listplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional:    true,
											ElementType: types.StringType,
											Description: `Requires replacement if changed. `,
										},
										"title": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Title of entity. Requires replacement if changed. `,
										},
										"updated_at": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Requires replacement if changed. `,
											Validators: []validator.String{
												validators.IsRFC3339(),
											},
										},
										"additional_properties": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional:    true,
											Description: `Parsed as JSON.`,
											Validators: []validator.String{
												validators.IsValidJSON(),
											},
										},
									},
									Description: `Requires replacement if changed. `,
								},
								"settings_flag": schema.ListNestedAttribute{
									PlanModifiers: []planmodifier.List{
										listplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												PlanModifiers: []planmodifier.Bool{
													boolplanmodifier.RequiresReplaceIfConfigured(),
												},
												Optional:    true,
												Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
											},
											"name": schema.StringAttribute{
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplaceIfConfigured(),
												},
												Optional:    true,
												Description: `The name of the organization setting to check. Requires replacement if changed. `,
											},
										},
									},
									Description: `This action should only be active when all the settings have the correct value. Requires replacement if changed. `,
								},
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"add_button_label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Optional label for the add button. The translated value for add_button_lable is used, if found else the string is used as is. Requires replacement if changed. `,
					},
					"allowed_schemas": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"details_view_mode_enabled": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enables the preview, edition, and creation of relation items on a Master-Details view mode. Requires replacement if changed. ; Default: false`,
					},
					"drawer_size": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["small", "medium", "large"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"small",
								"medium",
								"large",
							),
						},
					},
					"edit_mode": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["list-view"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"list-view",
							),
						},
					},
					"enable_relation_picker": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `When enable_relation_picker is set to true the user will be able to pick existing relations as values. Otherwise, the user will need to create new relation to link. Requires replacement if changed. ; Default: true`,
					},
					"enable_relation_tags": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `When enable_relation_tags is set to true the user will be able to set tags(labels) in each relation item. Requires replacement if changed. ; Default: true`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"has_primary": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"relation_affinity_mode": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Weak relation attributes are kept when duplicating an entity. Strong relation attributes are discarded when duplicating an entity. Requires replacement if changed. ; must be one of ["weak", "strong"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"weak",
								"strong",
							),
						},
					},
					"relation_type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["has_many", "has_one"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"has_many",
								"has_one",
							),
						},
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"reverse_attributes": schema.MapAttribute{
						PlanModifiers: []planmodifier.Map{
							mapplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Map of schema slug to target relation attribute. Requires replacement if changed. `,
					},
					"search_placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Optional placeholder text for the relation search input. The translated value for search_placeholder is used, if found else the string is used as is. Requires replacement if changed. `,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"summary_fields": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"str": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Requires replacement if changed. `,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("summary_field"),
										}...),
									},
								},
								"summary_field": schema.SingleNestedAttribute{
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"display_as": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional:    true,
											Description: `An hint on how to display the summary field. Requires replacement if changed. `,
										},
										"field": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional:    true,
											Description: `The field from the entity attributes to display. Requires replacement if changed. `,
										},
									},
									Description: `Summary Fields are displayed inside list view as a resume of the relation entity. Requires replacement if changed. `,
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("str"),
										}...),
									},
								},
							},
							Validators: []validator.Object{
								validators.ExactlyOneChild(),
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["relation"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"relation",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Entity Relationship. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"repeatable_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"enable_relation_picker": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `when enable_relation_picker is set to true the user will be able to pick existing relations as values. Otherwise, the user will need to create new relation to link. Requires replacement if changed. ; Default: true`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"has_primary": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"relation_affinity_mode": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Weak repeatable attributes are kept when duplicating an entity. Strong repeatable attributes are discarded when duplicating an entity. Requires replacement if changed. ; must be one of ["weak", "strong"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"weak",
								"strong",
							),
						},
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"repeatable": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["string", "phone", "email", "address", "relation", "payment", "price_component", "date"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"string",
								"phone",
								"email",
								"address",
								"relation",
								"payment",
								"price_component",
								"date",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Repeatable (add N number of fields). Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"select_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"allow_any": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Allow arbitrary input values in addition to provided options. Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"options": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"str": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Requires replacement if changed. `,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
										}...),
									},
								},
								"one": schema.SingleNestedAttribute{
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"title": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional:    true,
											Description: `Requires replacement if changed. `,
										},
										"value": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `Requires replacement if changed. `,
										},
									},
									Description: `Requires replacement if changed. `,
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("str"),
										}...),
									},
								},
							},
							Validators: []validator.Object{
								validators.ExactlyOneChild(),
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["select", "radio"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"select",
								"radio",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Dropdown select. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"sequence_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"prefix": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Prefix added before the sequence number. Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"start_number": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["sequence"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"sequence",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Sequence of unique identifiers. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"slug": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Required:    true,
				Description: `Schema Slug. Requires replacement if changed. `,
			},
			"status_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"options": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"str": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Requires replacement if changed. `,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("two"),
										}...),
									},
								},
								"two": schema.SingleNestedAttribute{
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"title": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Optional:    true,
											Description: `The displayed title of the option. Requires replacement if changed. `,
										},
										"value": schema.StringAttribute{
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Required:    true,
											Description: `The stored value of the option. Requires replacement if changed. `,
										},
									},
									Description: `Requires replacement if changed. `,
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("str"),
										}...),
									},
								},
							},
							Validators: []validator.Object{
								validators.ExactlyOneChild(),
							},
						},
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["status"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"status",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Status select. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"tags_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"options": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"suggestions": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["tags"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"tags",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Tags. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"text_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"multiline": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["string"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"string",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `Textarea or text input. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("user_relation_attribute"),
					}...),
				},
			},
			"user_relation_attribute": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"purpose": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `Requires replacement if changed. `,
					},
					"constraints": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
						MarkdownDescription: `A set of constraints applicable to the attribute.` + "\n" +
							`These constraints should and will be enforced by the attribute renderer.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"default_value": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"deprecated": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"entity_builder_disable_edit": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Setting to ` + "`" + `true` + "`" + ` disables editing the attribute on the entity builder UI. Requires replacement if changed. ; Default: false`,
					},
					"feature_flag": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `This attribute should only be active when the feature flag is enabled. Requires replacement if changed. `,
					},
					"group": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Which group the attribute should appear in. Accepts group ID or group name. Requires replacement if changed. `,
					},
					"hidden": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Do not render attribute in entity views. Requires replacement if changed. ; Default: false`,
					},
					"hide_label": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `When set to true, will hide the label of the field. Requires replacement if changed. `,
					},
					"icon": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Code name of the icon to used to represent this attribute.` + "\n" +
							`The value must be a valid @epilot/base-elements Icon name` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"id": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `ID for the entity attribute. Requires replacement if changed. `,
					},
					"info_helpers": schema.SingleNestedAttribute{
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"hint_custom_component": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The name of the custom component to be used as the hint helper.` + "\n" +
									`The component should be registered in the ` + "`" + `@epilot360/entity-ui` + "`" + ` on the index of the components directory.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text` + "`" + ` or ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The text to be displayed in the attribute hint helper.` + "\n" +
									`When specified it overrides the ` + "`" + `hint_text_key` + "`" + ` configuration.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_text_key": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The key of the hint text to be displayed in the attribute hint helper.` + "\n" +
									`The key should be a valid i18n key.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
							"hint_tooltip_placement": schema.StringAttribute{
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
								},
								Optional: true,
								MarkdownDescription: `The placement of the hint tooltip.` + "\n" +
									`The value should be a valid ` + "`" + `@mui/core` + "`" + ` tooltip placement.` + "\n" +
									`` + "\n" +
									`Requires replacement if changed. `,
							},
						},
						Description: `A set of configurations meant to document and assist the user in filling the attribute. Requires replacement if changed. `,
					},
					"label": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"layout": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"multiple": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `Requires replacement if changed. `,
					},
					"order": schema.Int64Attribute{
						PlanModifiers: []planmodifier.Int64{
							int64planmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Attribute sort order (ascending) in group. Requires replacement if changed. `,
					},
					"placeholder": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"preview_value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"protected": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Setting to ` + "`" + `true` + "`" + ` prevents the attribute from being modified / deleted. Requires replacement if changed. ; Default: true`,
					},
					"readonly": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"render_condition": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						MarkdownDescription: `Defines the conditional rendering expression for showing this field.` + "\n" +
							`When a valid expression is parsed, their evaluation defines the visibility of this attribute.` + "\n" +
							`Note: Empty or invalid expression have no effect on the field visibility.` + "\n" +
							`` + "\n" +
							`Requires replacement if changed. `,
					},
					"required": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Requires replacement if changed. ; Default: false`,
					},
					"settings_flag": schema.ListNestedAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `Whether the setting should be enabled or not. Requires replacement if changed. `,
								},
								"name": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The name of the organization setting to check. Requires replacement if changed. `,
								},
							},
						},
						Description: `This attribute should only be active when all the settings have the correct value. Requires replacement if changed. `,
					},
					"show_in_table": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Render as a column in table views. When defined, overrides ` + "`" + `hidden` + "`" + `. Requires replacement if changed. `,
					},
					"sortable": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Allow sorting by this attribute in table views if ` + "`" + `show_in_table` + "`" + ` is true. Requires replacement if changed. ; Default: true`,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. ; must be one of ["relation_user"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"relation_user",
							),
						},
					},
					"value_formatter": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
				},
				Description: `User Relationship. Requires replacement if changed. `,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("address_relation_attribute"),
						path.MatchRelative().AtParent().AtName("automation_attribute"),
						path.MatchRelative().AtParent().AtName("boolean_attribute"),
						path.MatchRelative().AtParent().AtName("computed_attribute"),
						path.MatchRelative().AtParent().AtName("consent_attribute"),
						path.MatchRelative().AtParent().AtName("country_attribute"),
						path.MatchRelative().AtParent().AtName("currency_attribute"),
						path.MatchRelative().AtParent().AtName("date_attribute"),
						path.MatchRelative().AtParent().AtName("file_attribute"),
						path.MatchRelative().AtParent().AtName("internal_attribute"),
						path.MatchRelative().AtParent().AtName("internal_user_attribute"),
						path.MatchRelative().AtParent().AtName("invitation_email_attribute"),
						path.MatchRelative().AtParent().AtName("link_attribute"),
						path.MatchRelative().AtParent().AtName("multi_select_attribute"),
						path.MatchRelative().AtParent().AtName("number_attribute"),
						path.MatchRelative().AtParent().AtName("ordered_list_attribute"),
						path.MatchRelative().AtParent().AtName("partner_organisation_attribute"),
						path.MatchRelative().AtParent().AtName("partner_status_attribute"),
						path.MatchRelative().AtParent().AtName("payment_method_relation_attribute"),
						path.MatchRelative().AtParent().AtName("purpose_attribute"),
						path.MatchRelative().AtParent().AtName("relation_attribute"),
						path.MatchRelative().AtParent().AtName("repeatable_attribute"),
						path.MatchRelative().AtParent().AtName("select_attribute"),
						path.MatchRelative().AtParent().AtName("sequence_attribute"),
						path.MatchRelative().AtParent().AtName("status_attribute"),
						path.MatchRelative().AtParent().AtName("tags_attribute"),
						path.MatchRelative().AtParent().AtName("text_attribute"),
					}...),
				},
			},
		},
	}
}

func (r *SchemaAttributeResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *SchemaAttributeResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *SchemaAttributeResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	slug := data.Slug.ValueString()
	attribute := data.ToSharedAttribute()
	request := operations.CreateSchemaAttributeRequest{
		Slug:      slug,
		Attribute: attribute,
	}
	res, err := r.client.Schemas.CreateSchemaAttribute(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.AttributeWithCompositeID == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAttributeWithCompositeID(res.AttributeWithCompositeID)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	compositeID := data.CompositeID.ValueString()
	request1 := operations.GetSchemaAttributeRequest{
		CompositeID: compositeID,
	}
	res1, err := r.client.Schemas.GetSchemaAttribute(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if res1.AttributeWithCompositeID == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromSharedAttributeWithCompositeID(res1.AttributeWithCompositeID)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SchemaAttributeResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *SchemaAttributeResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	compositeID := data.CompositeID.ValueString()
	request := operations.GetSchemaAttributeRequest{
		CompositeID: compositeID,
	}
	res, err := r.client.Schemas.GetSchemaAttribute(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.AttributeWithCompositeID == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAttributeWithCompositeID(res.AttributeWithCompositeID)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SchemaAttributeResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *SchemaAttributeResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	compositeID := data.CompositeID.ValueString()
	attributeWithCompositeID := data.ToSharedAttributeWithCompositeIDInput()
	request := operations.PutSchemaAttributeRequest{
		CompositeID:              compositeID,
		AttributeWithCompositeID: attributeWithCompositeID,
	}
	res, err := r.client.Schemas.PutSchemaAttribute(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.AttributeWithCompositeID == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAttributeWithCompositeID(res.AttributeWithCompositeID)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SchemaAttributeResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *SchemaAttributeResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	compositeID := data.CompositeID.ValueString()
	request := operations.DeleteSchemaAttributeRequest{
		CompositeID: compositeID,
	}
	res, err := r.client.Schemas.DeleteSchemaAttribute(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *SchemaAttributeResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("composite_id"), req.ID)...)
}
